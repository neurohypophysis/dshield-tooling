#!/bin/bash

set -euo pipefail

usage() {
  cat <<EOF
Usage: $0 [options] logfile.jsonl

Options:
  -s, --start        Start timestamp (inclusive), e.g. 2025-07-27T05:00:00
  -e, --end          End timestamp (inclusive), e.g. 2025-07-28T00:00:00
  -i, --interval     Interval for aggregation: minute, hour, day, week, month (default: hour)
  -F, --fill-empty   Fill missing intervals with 0
  -nh, --no-hist Do not print histogram bars, just TSV output

Example:
  $0 -s 2025-07-27T00:00:00 -e 2025-07-28T00:00:00 -i day logs.jsonl
EOF
  exit 1
}

INTERVAL="hour"
START_TS=""
END_TS=""
LOGFILE=""
NO_HISTOGRAM=0
FILL_EMPTY=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    -s|--start)
      START_TS="$2"
      shift 2
      ;;
    -e|--end)
      END_TS="$2"
      shift 2
      ;;
    -i|--interval)
      INTERVAL="$2"
      shift 2
      ;;
    -F|--fill-empty)
      FILL_EMPTY=1
      shift
      ;;
    -nh|--no-hist)
      NO_HISTOGRAM=1
      shift
      ;;
    -*)
      echo "Unknown option: $1"
      usage
      ;;
    *)
      LOGFILE="$1"
      shift
      ;;
  esac
done

if [[ -z "$LOGFILE" || ! -f "$LOGFILE" ]]; then
    if [[ -t 0 ]]; then
        echo "Error: logfile missing or not found."
        usage
    else
        input="-"
        LOGFILE="stdin"
    fi
else
    input="$LOGFILE"
fi


case "$INTERVAL" in
  minute|hour|day|week|month) ;;
  *)
    echo "Invalid interval: $INTERVAL"
    usage
    ;;
esac

[[ $NO_HISTOGRAM -eq 0 ]] && echo "=== Requests Per $INTERVAL ==="
[[ $NO_HISTOGRAM -eq 0 ]] && echo "Log file: $LOGFILE"
[[ -n "$START_TS" && $NO_HISTOGRAM -eq 0 ]] && echo "Start: $START_TS"
[[ -n "$END_TS" && $NO_HISTOGRAM -eq 0 ]] && echo "End: $END_TS"
[[ $NO_HISTOGRAM -eq 0 ]] && echo



jq -r 'if type=="array" then .[] else . end | .time // .timestamp' "$input" | awk -v start="$START_TS" -v end="$END_TS" -v interval="$INTERVAL" -v nohist="$NO_HISTOGRAM" -v fill_empty="$FILL_EMPTY" '
function in_range(ts) {
  return (start == "" || ts >= start) && (end == "" || ts <= end)
}

function truncate_ts(ts, cmd, out) {
  if (interval == "minute") {
    return substr(ts, 1, 16)
  } else if (interval == "hour") {
    return substr(ts, 1, 13)
  } else if (interval == "day") {
    return substr(ts, 1, 10)
  } else if (interval == "month") {
    return substr(ts, 1, 7)
  } else if (interval == "week") {
    cmd = "date -d \"" ts "\" +%G-W%V"
    cmd | getline out
    close(cmd)
    return out
  }
  return ts
}

function next_interval(ts,    cmd, out) {
  if (interval == "hour") cmd = "date -d \"" ts " +1 hour\" +%Y-%m-%dT%H"
  else if (interval == "day") cmd = "date -d \"" ts " +1 day\" +%Y-%m-%d"
  else if (interval == "minute") cmd = "date -d \"" ts " +1 min\" +%Y-%m-%dT%H:%M"
  else if (interval == "month") cmd = "date -d \"" ts " +1 month\" +%Y-%m"
  else if (interval == "week") cmd = "date -d \"" ts " +7 day\" +%Y-%m-%d"
  cmd | getline out
  close(cmd)
  return out
}

{
  ts = $0
  if (in_range(ts)) {
    key = truncate_ts(ts)
    counts[key]++
  }
}

END {
  PROCINFO["sorted_in"] = "@ind_str_asc"

 if (fill_empty == 1) {
    prev = ""
    for (k in counts) {
      if (prev != "") {
        t = prev
        while (1) {
          next_ts = next_interval(t)
          if (next_ts >= k) break
          counts[next_ts] = 0
          t = next_ts
        }
      }
      prev = k
    }
  }


  if (nohist == 1) {
    for (k in counts) {
      print k "\t" counts[k]
    }
    exit
  }

  max_count = 0
  for (k in counts) {
    if (counts[k] > max_count) max_count = counts[k]
  }

  term_width = 80
  cmd = "tput cols"
  cmd | getline term_width
  close(cmd)

  label_width = 25
  bar_max_width = term_width - label_width
  if (bar_max_width < 10) bar_max_width = 10

  for (k in counts) {
    count = counts[k]
    bar_len = int((count / max_count) * bar_max_width)
    if (bar_len < 1) bar_len = 1
    bar = ""
    for (i = 0; i < bar_len; i++) bar = bar "#"
    printf "%-16s %5d %s\n", k, count, bar
  }
}
'

